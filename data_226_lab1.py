# -*- coding: utf-8 -*-
"""Data_226_Lab1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cF3-3-SoZsUF_KGmsZD8Pc3LTUQNgSz5
"""

from airflow import DAG
from airflow.decorators import task
from airflow.providers.snowflake.hooks.snowflake import SnowflakeHook
from datetime import datetime, timedelta
from airflow.models import Variable
import requests
import pandas as pd
import logging

def get_snowflake_conn():
    snowflake_hook = SnowflakeHook(snowflake_conn_id='snowflake_conn')
    return snowflake_hook.get_conn()

default_args = {
    'owner': 'Lab1',
    'start_date': datetime(2024, 10, 12),
    'retries': 1,
}

with DAG(
    dag_id='forecast_stock',
    default_args=default_args,
    schedule_interval='0 18 * * *',
    catchup=False
) as dag:

    @task
    def create_table():
        conn = get_snowflake_conn()
        cur = conn.cursor()
        try:
            cur.execute("USE DATABASE alpha_vabtage_stocks")
            cur.execute("USE SCHEMA raw_data")

            create_table_query = """
            CREATE OR REPLACE TABLE raw_data.stock_price (
                date DATE,
                open FLOAT,
                high FLOAT,
                low FLOAT,
                close FLOAT,
                volume FLOAT,
                symbol STRING
            );
            """
            cur.execute(create_table_query)
            logging.info("Table raw_data.stock_price created successfully.")
        except Exception as e:
            logging.error(f"Error creating table: {e}")
            raise e
        finally:
            cur.close()
            conn.close()

    @task
    def fetch_stock_data(symbol):
        api_key = Variable.get('vantage_api_key')
        url = f"https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol={symbol}&apikey={api_key}&outputsize=full"
        response = requests.get(url)
        data = response.json()

        time_series = data.get('Time Series (Daily)', {})
        if not time_series:
            logging.error(f"No data returned for {symbol}: {data.get('Note', 'Unknown error')}")
            return None

        df = pd.DataFrame.from_dict(time_series, orient='index')
        df = df.reset_index().rename(columns={
            'index': 'date',
            '1. open': 'open',
            '2. high': 'high',
            '3. low': 'low',
            '4. close': 'close',
            '5. volume': 'volume'
        })

        df['date'] = pd.to_datetime(df['date'])
        three_months_ago = datetime.now() - timedelta(days=90)
        df = df[df['date'] >= three_months_ago]

        df['symbol'] = symbol
        df['date'] = df['date'].dt.strftime('%Y-%m-%d')

        logging.info(f"Fetched and filtered {symbol} data: {df.head()}")
        return df.to_dict(orient='records')

    @task
    def insert_stock_data(stock_data, symbol):
        if stock_data is None:
            logging.error(f"No stock data to insert for {symbol}.")
            return

        conn = get_snowflake_conn()
        cur = conn.cursor()
        insert_query = """
        INSERT INTO raw_data.stock_price (date, open, high, low, close, volume, symbol)
        VALUES (%(date)s, %(open)s, %(high)s, %(low)s, %(close)s, %(volume)s, %(symbol)s)
        """
        try:
            for record in stock_data:
                cur.execute(insert_query, record)
            cur.execute("COMMIT;")
            logging.info(f"Successfully inserted data for {symbol}")
        except Exception as e:
            cur.execute("ROLLBACK;")
            logging.error(f"Error inserting data for {symbol}: {e}")
            raise e
        finally:
            cur.close()
            conn.close()

    @task
    def create_forecast_table():
        hook = SnowflakeHook(snowflake_conn_id='snowflake_conn')
        conn = hook.get_conn()

        create_forecast_table_sql = """
        CREATE OR REPLACE TABLE raw_data.stock_forecast AS
        WITH max_date AS (
            SELECT MAX(date) AS max_date
            FROM raw_data.stock_price
        )
        SELECT
            DATEADD(DAY, seq4(), md.max_date) AS PREDICT_DATE,
            MAX(sp.close) AS PREDICTED_CLOSE,
            sp.symbol
        FROM
            raw_data.stock_price sp,
            max_date md
        WHERE
            DATEADD(DAY, seq4(), md.max_date) <= CURRENT_DATE() + INTERVAL '14 DAY'
        GROUP BY
            seq4(), md.max_date, sp.symbol
        QUALIFY
            ROW_NUMBER() OVER (PARTITION BY sp.symbol ORDER BY PREDICTED_CLOSE) <= 7;  -- Limit to 7 predictions per symbol
        """

        with conn.cursor() as cur:
            try:
                # Set the database and schema
                cur.execute("USE DATABASE alpha_vabtage_stocks")
                cur.execute("USE SCHEMA raw_data")
                cur.execute(create_forecast_table_sql)
                logging.info("Forecast table created successfully.")
            except Exception as e:
                logging.error(f"Error occurred while creating forecast table: {e}")
                raise

        conn.close()

    # Define task dependencies
    create_table_task = create_table()

    for symbol in ['NVDA', 'DPZ']:
        stock_data = fetch_stock_data(symbol)
        insert_task = insert_stock_data(stock_data, symbol)
        create_table_task >> stock_data >> insert_task

    # Add the forecast task after all stock data has been inserted
    forecast_task = create_forecast_table()
    insert_task >> forecast_task