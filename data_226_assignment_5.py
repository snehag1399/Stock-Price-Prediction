# -*- coding: utf-8 -*-
"""Lab1_Final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MuxLhH0JfjSfynBlf4RNYO4X-r4wEZM6
"""

from airflow import DAG
from airflow.decorators import task
from airflow.providers.snowflake.hooks.snowflake import SnowflakeHook
from datetime import datetime, timedelta
import logging

# Default DAG arguments
default_args = {
    'owner': 'Lab1',
    'start_date': datetime(2024, 10, 12),
    'retries': 0,
}

# DAG Definition
with DAG(
    dag_id='cortex_forecasting_dag',
    default_args=default_args,
    schedule_interval='@daily',  # Adjust the schedule as needed
    catchup=False
) as dag:

    # Task to set up the database and schema
    @task
    def setup_database():
        snowflake_hook = SnowflakeHook(snowflake_conn_id='snowflake_conn')
        conn = snowflake_hook.get_conn()
        cur = conn.cursor()
        try:
            cur.execute("USE ROLE ACCOUNTADMIN")
            cur.execute("USE WAREHOUSE LAB1")
            cur.execute("USE DATABASE ALPHA_VABTAGE_STOCKS")
            cur.execute("USE SCHEMA RAW_DATA")
            logging.info("Database and schema set up successfully.")
        except Exception as e:
            logging.error(f"Error setting up database/schema: {e}")
            raise
        finally:
            cur.close()
            conn.close()

    # Task to inspect the first 10 rows of the training data
    @task
    def inspect_training_data():
        snowflake_hook = SnowflakeHook(snowflake_conn_id='snowflake_conn')
        conn = snowflake_hook.get_conn()
        cur = conn.cursor()
        try:
            cur.execute("SELECT * FROM STOCK_PRICE LIMIT 10;")
            result = cur.fetchall()
            logging.info(f"First 10 rows of training data: {result}")
        except Exception as e:
            logging.error(f"Error inspecting training data: {e}")
            raise
        finally:
            cur.close()
            conn.close()

    # Task to create the training view
    @task
    def create_training_view():
        snowflake_hook = SnowflakeHook(snowflake_conn_id='snowflake_conn')
        conn = snowflake_hook.get_conn()
        cur = conn.cursor()
        try:
            create_view_query = """
            CREATE OR REPLACE VIEW STOCK_PRICE_v1 AS
            SELECT
                to_timestamp_ntz(DATE) AS DATE_v1,
                CLOSE,
                SYMBOL`
            FROM STOCK_PRICE;
            """
            cur.execute(create_view_query)
            logging.info("View STOCK_PRICE_v1 created successfully.")
        except Exception as e:
            logging.error(f"Error creating view: {e}")
            raise
        finally:
            cur.close()
            conn.close()

    # Task to create the forecasting model
    @task
    def create_forecast_model():
        snowflake_hook = SnowflakeHook(snowflake_conn_id='snowflake_conn')
        conn = snowflake_hook.get_conn()
        cur = conn.cursor()
        try:
            create_model_query = """
            CREATE OR REPLACE SNOWFLAKE.ML.FORECAST my_forecast_model(
                INPUT_DATA => SYSTEM$REFERENCE('VIEW', 'STOCK_PRICE_v1'),
                SERIES_COLNAME => 'SYMBOL',
                TIMESTAMP_COLNAME => 'DATE_v1',
                TARGET_COLNAME => 'CLOSE',
                CONFIG_OBJECT => { 'ON_ERROR': 'SKIP' }
            );
            """
            cur.execute(create_model_query)
            logging.info("Forecast model created successfully.")
        except Exception as e:
            logging.error(f"Error creating forecast model: {e}")
            raise
        finally:
            cur.close()
            conn.close()

    # Task to generate predictions and store the results
    @task
    def generate_predictions():
        snowflake_hook = SnowflakeHook(snowflake_conn_id='snowflake_conn')
        conn = snowflake_hook.get_conn()
        cur = conn.cursor()
        try:
            prediction_query = """
            BEGIN
                CALL my_forecast_model!FORECAST(
                    FORECASTING_PERIODS => 7,
                    CONFIG_OBJECT => {'prediction_interval': 0.95}
                );
                LET x := SQLID;
                CREATE TABLE My_forecasts_2024_10_14 AS SELECT * FROM TABLE(RESULT_SCAN(:x));
            END;
            """
            cur.execute(prediction_query)
            logging.info("Predictions generated and stored successfully.")
        except Exception as e:
            logging.error(f"Error generating predictions: {e}")
            raise
        finally:
            cur.close()
            conn.close()

    # Task to inspect results
    @task
    def inspect_results():
        snowflake_hook = SnowflakeHook(snowflake_conn_id='snowflake_conn')
        conn = snowflake_hook.get_conn()
        cur = conn.cursor()
        try:
            # Inspect accuracy metrics
            cur.execute("CALL my_forecast_model!SHOW_EVALUATION_METRICS();")
            metrics = cur.fetchall()
            logging.info(f"Model evaluation metrics: {metrics}")

            # Inspect feature importance
            cur.execute("CALL my_forecast_model!EXPLAIN_FEATURE_IMPORTANCE();")
            importance = cur.fetchall()
            logging.info(f"Feature importance: {importance}")

        except Exception as e:
            logging.error(f"Error inspecting results: {e}")
            raise
        finally:
            cur.close()
            conn.close()

    # Define task dependencies
    setup_db_task = setup_database()
    inspect_data_task = inspect_training_data()
    create_view_task = create_training_view()
    create_model_task = create_forecast_model()
    generate_predictions_task = generate_predictions()
    inspect_results_task = inspect_results()

    # Set the order of execution
    setup_db_task >> inspect_data_task >> create_view_task >> create_model_task >> generate_predictions_task >> inspect_results_task
